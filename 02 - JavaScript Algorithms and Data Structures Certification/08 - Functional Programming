*** FUNCTIONAL PROGRAMMING ***

In functional programming, code is organized into smaller, basic functions that can be combined to build complex programs

Learn about functional programming:
  isolated functions: no dependance of the state of the program
  pure functions: same input always gives the same output
  functions with limited side effects
  
Understand functional programming terminology:
  callbacks are the functions that are slipped or passed into another function to decide the invocation of that function
  unctions that can be assigned to a variable, passed into another function, or returned from another function, are called first class functions
  the functions that take a function as an argument, or return a function as a return value are called higher order functions
  when the functions are passed in to another function or returned from another function, then those functions which gets passed in or returned can be called a lambda
  
Avoid mutations an side effects using functional programming:
  one of the core principles of functional programming is not to change things
  in functional programming, changing or altering things is called mutation, and that outcome is called side-effect
  ideally, a function should be pure
  
Pass arguments to avoid external dependance in a function:
  another principle of functional programming is to always declare your dependencies explicitly
  this means if a function depends on a variable or object being present, then pass that variable or object directly into the function as an argument
  
Refactor global variables out of functions:
  careful: var newArr = arr does NOT create a new array, but creates a reference => if you modify newArr, this will alter arr as well
  any computation inside a function depends only on the arguments passed to the function, and not on any global object or variable

Use the map method to extract data from an array:
  map method iterates over each item in an array and returns a new array containing the results of calling the callback function on each element
  const names = users.map(user => user.name);
  
Implement map on a prototype:
  Array.prototype.myMap = function(callback) {
    var newArray = [];
    for(let i=0;i<this.length;i++){
      newArray[i]=callback(this[i]);
    }
    return newArray;
  };
  
Use the filter method to extract data from an array:
  filter calls a function on each element of an array and returns a new array containing only the elements for which that function returns true
  var filteredList= watchList.map(item=>({
    title: item['Title'],
    rating: item['imdbRating']
  }) )
  .filter(item=>(
    parseFloat(item.rating)>=8            // item.rating because watchList.map before changed it
  ))
  
Implement the filter method on a prototype:
  Array.prototype.myFilter = function(callback) {
  var newArray = [];
    for(let i=0;i<this.length;i++){
      if(callback(this[i])){
        newArray.push(this[i]);
      }
    };
    return newArray;
  };
  
Return part of an array using splice method:
  
